import os
import json
from typing import List
from models.firewall import ApplicationProtocol, FirewallPolicy, FirewallRule

HOST_FS_ROOT = os.getenv("HOST_FS_ROOT", "/host-fs")
FIREWALL_DIR = os.path.join(HOST_FS_ROOT, "etc/firewall")
RULES_SCRIPT = os.path.join(FIREWALL_DIR, "rules.sh")
STATE_FILE = os.path.join(FIREWALL_DIR, "state.json")

SUPPORTED_APPS = [
    ApplicationProtocol(id="youtube", name="YouTube", category="Video"),
    ApplicationProtocol(id="netflix", name="Netflix", category="Video"),
    ApplicationProtocol(id="facebook", name="Facebook", category="Social"),
    ApplicationProtocol(id="twitter", name="X / Twitter", category="Social"),
    ApplicationProtocol(id="instagram", name="Instagram", category="Social"),
    ApplicationProtocol(id="tiktok", name="TikTok", category="Social"),
    ApplicationProtocol(id="whatsapp", name="WhatsApp", category="Messaging"),
    ApplicationProtocol(id="telegram", name="Telegram", category="Messaging"),
    ApplicationProtocol(id="bittorrent", name="BitTorrent", category="P2P"),
    ApplicationProtocol(id="tor", name="Tor", category="Anonymizer"),
]

class FirewallService:
    @staticmethod
    def _ensure_dir():
        os.makedirs(FIREWALL_DIR, exist_ok=True)

    @staticmethod
    def get_supported_apps() -> List[ApplicationProtocol]:
        return SUPPORTED_APPS

    @staticmethod
    def get_policy() -> FirewallPolicy:
        FirewallService._ensure_dir()
        if not os.path.exists(STATE_FILE):
            return FirewallPolicy(rules=[])
        
        try:
            with open(STATE_FILE, 'r') as f:
                data = json.load(f)
            return FirewallPolicy(**data)
        except:
            return FirewallPolicy(rules=[])

    @staticmethod
    def update_policy(policy: FirewallPolicy):
        FirewallService._ensure_dir()
        
        # 1. Save State
        with open(STATE_FILE, 'w') as f:
            f.write(policy.model_dump_json(indent=2))

        # 2. Generate Shell Script
        with open(RULES_SCRIPT, 'w') as f:
            f.write("#!/bin/bash\n")
            f.write("# Auto-generated by UAC Controller\n")
            f.write("# Flushes existing Application Control rules\n\n")
            
            f.write("iptables -F UAC_APP_CONTROL 2>/dev/null || iptables -N UAC_APP_CONTROL\n")
            # Insert jump if not exists (mock logic)
            f.write("iptables -C FORWARD -j UAC_APP_CONTROL 2>/dev/null || iptables -I FORWARD -j UAC_APP_CONTROL\n\n")

            for rule in policy.rules:
                if rule.enabled and rule.action == "DROP":
                    # nDPI match syntax
                    f.write(f"# Block {rule.app_id}\n")
                    f.write(f"iptables -A UAC_APP_CONTROL -m ndpi --proto {rule.app_id} -j DROP\n")

        # Make executable
        os.chmod(RULES_SCRIPT, 0o755)
        
        return {"status": "updated", "script_path": RULES_SCRIPT}
